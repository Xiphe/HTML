<?php
/**
 * Cleaner class file
 *
 * @category Markup
 * @package  Xiphe\HTML
 * @author   Hannes Diercks <xiphe@gmx.de>
 * @license  http://www.gnu.org/licenses/gpl-2.0.txt GNU GENERAL PUBLIC LICENSE
 * @link     https://github.com/Xiphe/-HTML/blob/master/core/Cleaner.php
 */

namespace Xiphe\HTML\core;

/**
 * Cleaner class
 *
 * Handles messed up html markup strings and cleans them up
 * so they will fit into the markup generated by HTML
 *
 * @category Markup
 * @package  Xiphe\HTML
 * @author   Hannes Diercks <xiphe@gmx.de>
 * @license  http://www.gnu.org/licenses/gpl-2.0.txt GNU GENERAL PUBLIC LICENSE
 * @link     https://github.com/Xiphe/-HTML
 */
class Cleaner
{
    /**
     * How many Tags are allowed in a blocktag until its content
     * will be in a single line
     *
     * @var integer
     */
    protected static $maxOneLine = 1;

    /**
     * Echo Wrapper for get_clean()
     *
     * @param mixed $str string to be cleaned or Xiphe\HTML\core\Tag with content
     * 
     * @return void
     */
    public static function clean($str)
    {
        echo self::getClean($str);
    }

    /**
     * Cleans up the given content
     *
     * @param mixed $str string to be cleaned or Xiphe\HTML\core\Tag with content
     * 
     * @return string the cleaned string.
     */
    public static function getClean($str)
    {
        if (is_object($str) && get_class($str) == 'Xiphe\HTML\core\Tag') {
            $Tag = $str;
            $str = $Tag->content;
        }
        switch (Config::get('cleanMode')) {
        case 'strong':
            $str = self::getStrong($str);
            break;
        case 'basic':
            $str = self::getBasic($str);
            break;
        default:
            return $str;
        }
        if (isset($Tag)) {
            $Tag->content = $str;
        }

        return $str;
    }

    /**
     * Echo Wrapper for get_strong()
     *
     * @param string $str the string that will be cleaned up.
     * 
     * @return void
     */
    public static function strong($str)
    {
        echo self::getStrong($str);
    }

    /**
     * Echo Wrapper for get_basic()
     *
     * @param string $str the string that will be cleaned up.
     * 
     * @return void
     */
    public static function basic($str)
    {
        echo self::getBasic($str);
    }

    /**
     * unifies the tabs in the given string.
     *
     * @param string $str the string that will be cleaned up.
     * 
     * @return string
     */
    public static function getBasic($str)
    {
        $r = '';
        /*
         * Split the string by line breakes.
         */
        foreach (preg_split('/\n\r|\n|\r/', $str, -1, PREG_SPLIT_NO_EMPTY) as $k => $line) {
            /*
             * And append it with tabs and line breaks to the return var.
             */
            $r .= Generator::getTabs();
            $r .= trim($line);
            $r .= Generator::getLineBreak();
        }

        return $r;
    }

    /**
     * Parses tag attributes into an array.
     *
     * @param string $attr a sting with attributes or a starting tag
     *
     * @return array  the attributes in array form.
     */
    public static function parseAttrs($attr)
    {
        /*
         * Skip empty strings
         */
        if (trim($attr) == '') {
            return '';
        }

        /*
         * Match all attribute like parts from string.
         */
        preg_match_all('/[a-zA-Z0-9-_:.]+(\s?=\s?("|\')[^\2]*\2|\s)/U', $attr, $attr);

        /*
         * Get the interessting part.
         */
        $attr = $attr[0];

        $r = array();
        foreach ($attr as $k => $v) {
            /*
             * Skip empty matches
             */
            if (trim($v) == '') {
                continue;
            }

            /*
             * Split by the first = symbol.
             */
            $e = explode('=', $v, 2);
            /*
             * attribute name.
             */
            $at = trim($e[0]);
            /*
             * attribute value.
             */
            $val = isset($e[1]) ? trim($e[1]) : null;

            if ($val !== null) {
                /*
                 * trim the quotation symbols
                 */
                $val = trim($val, substr($val, 0, 1));
            }

            /*
             * store it in the return variable.
             */
            $r[$at] = $val;
        }

        return $r;
    }

    /**
     * Returns the current usable line with. (maxLineWidth-tabs*tabWorth or minLineWidth)
     *
     * @return integer
     */
    public static function getLineWidth()
    {
        $min = Config::get('minLineWidth');
        $width = Config::get('maxLineWidth');
        $width -= intval(Config::get('tabWorth'))*intval(Config::get('tabs'));

        if ($width < $min) {
            return $min;
        }

        return $width;
    }

    /**
     * Tears the given string into its smalest possible parts and rebuilds it
     * so it will fit nicely into the markup generated by Xiphe\HTML
     *
     * @param string $str the string that needs cleaning
     * 
     * @return string the cleaned string.
     */
    public static function getStrong($str)
    {
        /*
         * Split the content by html tags.
         */
        $tree = preg_split(
            '/(<[^!]?[^>]+>(<![^>]+>)?)/',
            $str,
            -1,
            PREG_SPLIT_OFFSET_CAPTURE | PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY
        );

        /*
         * Initiate variables.
         */
        $r = array();
        $line = '';
        $isInline = true;
        $oneLine = array();
        $lastWasTag = false;

        /*
         * Loop throu the tree.
         */
        foreach ($tree as $k => $elm) {
            /*
             * Check what kind of element this is.
             */
            $info;
            switch (self::_getTreeElm($elm[0], $info)) {
            case 'start':
                /*
                 * It's a starting tag
                 */
                $add = new Tag(
                    $info[1], /* The Tags Name */
                    array(self::parseAttrs($info[2])), /* The attributes */
                    array(
                        'generate',
                        ($info[3] == '/>' ? 'selfQlose' : 'doNotSelfQlose'),
                        'start',
                        (in_array($info[1], TagInfo::$inlineTags) ? 'inline' : null)
                    )
                );
                break;
            case 'end':
                /*
                 * It is a closing tag
                 */
                $add = Store::get('last');
                break;
            case 'comment':
            case 'content':
            default:
                /*
                 * It's something else
                 */
                $add = $elm[0];
                break;
            }

            /*
             * Add the current content to the output.
             */
            self::_toLine($add, $r, $line, $isInline, $oneLine, $lastWasTag);
        }

        /*
         * Check if there is still content in the current line
         * and add it to the return array.
         */
        if (strlen($line)) {
            $r[] = $line;
        }

        /*
         * implode the return array using line breaks and return the string.
         */

        return implode(Generator::getLineBreak(), $r).Generator::getLineBreak();
    }

    /**
     * This method recieves a string or Tag object and will decide if
     * it should be placed into a new line or added to the current one.
     *
     * @param mixed   $str         the Tag object or string to be added to the output
     * @param array   &$r          the current output
     * @param string  &$line       the current line that is passed to the output array when its full
     * @param boolean &$isInline   flag if the previous content allowed inline content
     * @param array   &$oneLine    array of tag id's used to put verry short content into one line
     * @param mixed   &$lastWasTag weather or not the last entry was a tag. (false if not, TagName if yes).
     * 
     * @return void
     */
    private static function _toLine($str, &$r, &$line, &$isInline, &$oneLine, &$lastWasTag)
    {
        /*
         * Get current line width and tab symbol
         */
        $width = Cleaner::getLineWidth();
        $tabs = Generator::getTabs();

        /*
         * Check if the given content is Tag object.
         */
        if (is_object($str)) {
            /*
             * Initiate additional variables.
             */
            $Tag = $str;
            $isInline = in_array($Tag->realName, TagInfo::$inlineTags);
            $isClose = $Tag->wasOpened();
            $str = trim($Tag->__tostring());
            $isTag = $Tag->name;


            if ($isClose) {
                /*
                 * Update Tabs because they were decresed by closing.
                 */
                $tabs = Generator::getTabs();

                /*
                 * Check if one-line is possible
                 * (TagID is last in $oneLine array and content is not to long.)
                 */
                if (!empty($oneLine) && end($oneLine) === $Tag->ID
                    && !in_array($Tag->name, TagInfo::$inlineTags)
                    && strlen(rtrim(end($r))) + strlen(trim($line)) + strlen(trim($str)) <= $width
                ) {
                    /*
                     * Remove the closing comment.
                     */
                     $str = preg_replace('/<!--[^>]*>/', '', $str);

                     /*
                      * Add the current line and content to the last line in $r.
                      */
                    $r[key($r)] .= trim($line).trim($str);

                    /*
                     * Reinitiate the vars.
                     */
                    $line = '';
                    $lastWasTag = $isTag;
                    $oneLine = array();

                    return;
                }

                /*
                 * Remove TagID from $oneLine checker.
                 */
                unset($oneLine[key($oneLine)]);
            } else {
                /*
                 * Try to add the current TagID to the $oneLine checker
                 */
                if (self::$maxOneLine > 0) {
                    if (count($oneLine) > self::$maxOneLine) {
                        /*
                         * It's to long - shorten it!
                         */
                        array_splice($oneLine, 0, self::$maxOneLine);
                    }
                    $oneLine[] = $Tag->ID;
                }
            }
        } else {
            /*
             * Its not a tag.
             */
            $isTag = false;
            $isInline = true;
        }

        /*
         * Unify all spaces, tabs etc. to one space.
         */
        $str = preg_replace('/(\s)+/s', ' ', $str);

        if ($isInline) {
            /*
             * Try to add the current content to the current line.
             */

            if ($line == '') {
                /*
                 * Its a fresh line - add tabs.
                 */
                $line .= $tabs;
            }

            /*
             * Split the content into single words.
             */
            $strs = preg_split('/\s/', $str, -1, PREG_SPLIT_OFFSET_CAPTURE);

            /*
             * Fore each word.
             */
            foreach ($strs as $s) {
                $lineWidth = strlen(trim($line));

                /*
                 * Current Line is full - add it to the output and start a new one.
                 */
                if ($lineWidth && ($lineWidth + strlen(trim($s[0]))) > $width) {
                    $r[] = $line;
                    $line = '';
                    $line .= $tabs;
                }

                /*
                 * Check if the current word has to be seperated by a space.
                 */
                $glue = '';
                if ($s[1] > 0 && strlen(trim($line)) && substr($str, $s[1]-1, 1) == ' ') {
                    $glue = ' ';
                }

                /*
                 * Add it to the current line.
                 */
                $line .= $glue.trim($s[0]);
            }
        } else {
            if (strlen(trim($line))) {
                /*
                 * If there is content in the current line - add it to the output.
                 */
                $r[] = $line;
                $line = '';
            }

            /*
             * Add content to output.
             */
            $r[] = $tabs.$str;
            $isInline = true;
        }

        $lastWasTag = $isTag;
    }

    /**
     * Checks the type of the given tree element.
     *
     * @param string $str   the current tree element
     * @param array  &$info additional info will be inserted here
     * 
     * @return string the type.
     */
    private static function _getTreeElm($str, &$info)
    {
        /*
         * Normalize the string.
         */
        $str = preg_replace('/(\n\r|\n|\r|\s)+/', ' ', $str);

        /*
         * Identify it by checking its first symbols.
         */
        if (strpos($str, '</') === 0) {
            return 'end';
        } elseif (strpos($str, '<!') === 0) {
            return 'content';
        } elseif (strpos($str, '<!--') === 0) {
            return 'comment';
        } elseif (strpos($str, '<') === 0) {
            preg_match('/<([a-zA-Z0-9]+)(.*?(?=\/>|>))(\/>|>)+/', $str, $info);

            return 'start';
        }

        return 'content';
    }
}
