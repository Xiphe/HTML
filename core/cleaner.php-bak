<?php

namespace Xiphe\HTML\core;

class Cleaner {

	public static function clean($str)
	{
		if (is_object($str) && get_class($str) == 'Xiphe\HTML\core\Tag') {
			$Tag = $str;
			$str = $Tag->content;
		}
		switch (Config::get('cleanMode')) {
			case 'strong':
				return self::get_strong($str);
			case 'basic':
				return trim(self::basic($str));
			default:
				return $str;
		}
	}

	public static function get_basic($str)
	{
		$width = self::get_lineWidth();
		$r = '';
		$line = '';
		foreach (preg_split('/\s/', $str, -1, PREG_SPLIT_NO_EMPTY) as $k => $word) {
			$word = trim($word);
			if ((strlen($line) + strlen($word) + 1) > $width) {
				$r .= Generator::get_tabs();
				$r .= trim($line);
				$r .= Generator::get_lineBreak();
				$line = '';
			}
			$line .= ' '.$word;
		}
		if ($line != '') {
			$r .= Generator::get_tabs();
			$r .= trim($line);
			$r .= Generator::get_lineBreak();
		}
		return $r;
	}

	public static function get_lineWidth()
	{
		$min = Config::get('minLineWidth');
		$width = Config::get('maxLineWidth');
		$width -= intval(Config::get('tabWorth'))*intval(Config::get('tabs'));

		if ($width < $min) {
			return $min;
		}
		return $width;
	}

	public static function get_strong($str) {
		$tree = preg_split(
			'/(<[^!]?[^>]+>(<![^>]+>)?)/', 
			$str, 
			-1, 
			PREG_SPLIT_OFFSET_CAPTURE | PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY
		);

		$r = '';
		$line = '';

		$Tag = false;
		$open = 0;
		$isInline = true;

		$toLine = function($str) use (&$r, &$line, &$isInline) {
			$width = self::get_lineWidth();
			if ($isInline && !preg_match('/\n\r|\n|\r/', $str) ) {
				if ((strlen($line) + strlen(trim($str)) + 1) > $width) {
					$r += $line;
					$line = '';
				}
				$line += ' '+trim($str);
			} else {
				if (strlen($line)) {
					$r += $line;
				}
				$r += $str;
				$isInline = true;
			}
		};

		foreach ($tree as $k => $elm) {
			if (trim($elm[0]) == '') {
				unset($tree[$k]);
				continue;
			}
			$info;
			switch (self::_get_treeelm($elm[0], $info)) {
				case 'start':
					if ($Tag === false) {
						$Tag = new Tag(
							$info[1],
							array(null, self::parseAttrs($info[2])),
							array('generate', ($info[3] == '/>' ? 'selfQlose' : null), 'cleanContent')
						);
						if ($info[2] == '/>') {
							$toLine($Tag);
							$Tag = false;
							$isInline = true;
						} else {
							if (in_array($Tag->realName, TagInfo::$inlineTags)) {
								$isInline = true;
							} else {
								$isInline = false;
							}
						}
					} else {
						$open++;
						$Tag->content .= $elm[0];
					}
					break;
				case 'end':
					if ($open > 0) {
						$open--;
					} else {
						$Tag->update('inlineInner');
						echo $Tag;
						$Tag = false;
						break;
					}
				case 'comment':
				case 'content':
					if ($Tag === false) {
						echo self::basic($elm[0]);
					} else {
						$Tag->content .= $elm[0];
					}
					break;
			}
		}
		return $r;
	}

	public static function strong($str)
	{
		echo self::get_strong($str);
	}

	public static function basic($str)
	{
		echo self::get_basic($str);
	}

	private $_Tag;


	public static function parseAttrs($attr)
	{
		if (trim($attr) == '') {
			return '';
		}

		preg_match_all('/([a-zA-Z0-9-_:.]+)\s?=\s?("|\')([^\2])*\2/U', $attr, $attr);

		$attr = $attr[0];

		$r = array();
		foreach ($attr as $k => $v) {
			if (trim($v) == '') {
				continue;
			}

			$e = explode('=', $v, 2);
			$at = trim($e[0]);
			if (!isset($e[1])) {
				var_dump( $o );
				var_dump( $v );
				die();
			}

			$val = trim($e[1]);

			$r[$at] = trim($val, substr($val, 0, 1));
		}
		return $r;
	}

	private static function _get_treeelm($str, &$info) {
		$str = preg_replace('/(\n\r|\n|\r|\s)+/', ' ', $str);
		if (strpos($str, '</') === 0) {
			return 'end';
		} elseif (strpos($str, '<!--') === 0) {
			return 'comment';
		} elseif (strpos($str, '<') === 0) {
			preg_match('/<([a-zA-Z0-9]+)(.*?(?=\/>|>))(\/>|>)+/', $str, $info);
			return 'start';
		}
		return 'content';
	}
}